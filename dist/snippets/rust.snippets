snippet allow
	#![allow(${1})]
snippet deny
	#![deny(${1})]
snippet warn
	#![warn(${1})]
snippet no_std
	#![no_std]
snippet no_core
	#![no_core]
snippet feature
	#![feature(${1})]
snippet macro_use
	#[macro_use(${1})]
snippet repr
	#[repr(${1})]
snippet cfg
	#[cfg(${1})]
snippet cfg_attr
	#[cfg_attr(${1}, ${2})]
snippet cfg
	cfg!(${1})
snippet column
	column!()
snippet concat
	concat!(${1})
snippet concat_idents
	concat_idents!(${1})
snippet debug_assert
	debug_assert!(${1});
snippet debug_assert_eq
	debug_assert_eq!(${1}, ${2});
snippet env
	env!("${1}")
snippet file
	file!()
snippet format
	format!("${1:{${2::?}}}")
snippet format_args
	format_args!("${1:{${2::?}}}")
snippet include
	include!("${1}");
snippet include_bytes
	include_bytes!("${1}")
snippet include_str
	include_str!("${1}")
snippet line
	line!()
snippet module_path
	module_path!()
snippet option_env
	option_env!("${1}")
snippet panic
	panic!("${1:{${2::?}}}");
snippet print
	print!("${1:{${2::?}}}");
snippet println
	println!("${1:{${2::?}}}");
snippet stringify
	stringify!(${1})
snippet thread_local
	thread_local!(static ${1:STATIC}: ${2:Type} = ${4:init});
snippet try
	try!(${1})
snippet unimplemented
	unimplemented!()
snippet unreachable
	unreachable!(${1})
snippet vec
	vec![${1}]
snippet write
	write!(${1}, "${2:{${3::?}}}")
snippet writeln
	writeln!(${1}, "${2:{${3::?}}}")
snippet Err
	Err(${1})
snippet Ok
	Ok(${1:result})
snippet Some
	Some(${1})
snippet assert
	assert!(â€¦);
snippet assert_eq
	assert_eq!(${1}, ${2});
snippet bench
	#[bench]
	fn ${1:name}(b: &mut test::Bencher) {
		${2:b.iter(|| ${3:/* benchmark code */})}
	}
snippet const
	const ${1:CONST}: ${2:Type} = ${4:init};
snippet derive
	#[derive(${1})]
snippet else
	else {
		${1:unimplemented!();}
	}
snippet extern-crate
	extern crate ${1:name};
snippet extern-fn
	extern "C" fn ${1:name}(${2:arg}: ${3:Type}) -> ${4:RetType} {
		${5:// add code here}
	}
snippet extern-mod
	extern "C" {
		${2:// add code here}
	}
snippet fn
	fn ${1:name}(${2:arg}: ${3:Type}) -> ${4:RetType} {
		${5:unimplemented!();}
	}
snippet for
	for ${1:pat} in ${2:expr} {
		${3:unimplemented!();}
	}
snippet if-let
	if let ${1:Some(pat)} = ${2:expr} {
		${2:unimplemented!();}
	}
snippet if
	if ${1:condition} {
		${2:unimplemented!();}
	}
snippet impl-trait
	impl ${1:Trait} for ${2:Type} {
		${3:// add code here}
	}
snippet impl
	impl ${1:Type} {
		${2:// add code here}
	}
snippet let
	let ${1:pat} = ${2:expr};
snippet loop
	loop {
		${2:unimplemented!();}
	}
snippet macro_rules
	macro_rules! ${1:name} {
		(${2}) => (${3})
	}
snippet main
	fn main() {
		${1:unimplemented!();}
	}
snippet match
	match ${1:expr} {
		${2:Some(expr)} => ${3:expr},
		${4:None} => ${5:expr},
	}
snippet mod
	mod ${1:name};
snippet mod-block
	mod ${1:name} {
		${2:// add code here}
	}
snippet static
	static ${1:STATIC}: ${2:Type} = ${4:init};
snippet struct-tuple
	struct ${1:Name}(${2:Type});
snippet struct-unit
	struct ${1:Name};
snippet struct
	#[derive(Debug)]
	struct ${1:Name} {
		${2:field}: ${3:Type}
	}
snippet trait
	trait ${1:Name} {"
		${2:// add code here}
	}
snippet type
	type ${1:Alias} = ${2:Type};
snippet while-let
	while let ${1:Some(pat)} = ${2:expr} {
		${2:unimplemented!();}
	}
snippet while
	while ${1:condition} {
		${2:unimplemented!();}
	}
snippet enum
	#[derive(Debug)]
	enum ${1:Name} {
		${2:Variant1},
		${3:Variant2},
	}
